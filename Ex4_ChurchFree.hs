{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE DeriveFunctor #-}

module Ex4_ChurchFree where
  
import Control.Monad.Free (MonadFree, wrap)
import Control.Applicative (Applicative(..))
import Control.Monad (ap, join)


{-
   The free monad generated by composing a functor with itself 0-n times.
   >>= is horrendously inefficient; we must bubble from the top all the way to the 
   leaves of the tree every time!
-}
data Free f a 
  = Wrap (f (Free f a)) 
  | Pure a
  deriving Functor
  
instance Functor f => Applicative (Free f) where
  (<*>) = ap
  pure = Pure
  
instance Functor f => Monad (Free f) where
  -- Keep binding down layer by layer, until we reach the....
  (Wrap ffa) >>= f = Wrap $ fmap (>>= f) ffa
  
  -- ...leaf nodes; finally we can substitute them with a new layer.
  (Pure a) >>= f = f a 
  
instance Functor f => MonadFree f (Free f) where 
  wrap = Wrap

foldFree :: Monad m => (forall x . f x -> m x) -> Free f a -> m a
foldFree f (Pure a) = pure a
foldFree f (Wrap ffa) = f ffa >>= foldFree f


-- "f r -> r" handles the nested functor.
-- "a -> r" handles the pure value.
newtype CFree f a = CFree 
  { cFold :: forall r. (f r -> r) -> (a -> r) -> r
  }
   
cPure :: a -> CFree f a
cPure a = CFree (\_ onPure -> onPure a)

cWrap :: Functor f => f (CFree f a) -> CFree f a
cWrap ffa = CFree $ \onWrap onPure -> 
  let 
    foldIt free = cFold free onWrap onPure
    fr = fmap foldIt ffa
  in onWrap fr


cFoldFree :: Monad m => (forall x. f x -> m x) -> CFree f a -> m a
cFoldFree f (CFree foldIt) = foldIt (join . f) pure


church :: Functor f => Free f a -> CFree f a
church (Pure a) = cPure a
church (Wrap ffa) = cWrap (fmap church ffa)


unchurch :: CFree f a -> Free f a
unchurch free = cFold free Wrap Pure

{-
   Bind and map for CFree are completely different from Free's;
   We don't need to know anything about the f type constructor, because we
   don't touch it. It doesn't even need to be a functor.
-}
cMap :: (a -> b) -> CFree f a -> CFree f b
cMap f (CFree foldIt) = CFree $ \onWrap onPure ->
  foldIt onWrap (onPure . f)

cBind :: CFree f a -> (a -> CFree f b) -> CFree f b
cBind (CFree foldIt) f = CFree $ \onWrap onPure -> 
  foldIt onWrap (\a -> cFold (f a) onWrap onPure)


-- Instance definition boilerplate. Note that f need not be a Functor!
instance Functor (CFree f) where
  fmap = cMap

instance Applicative (CFree f) where
  (<*>) = ap  
  pure = cPure

instance Monad (CFree f) where
  (>>=) = cBind

instance Functor f => MonadFree f (CFree f) where 
  wrap = cWrap










  