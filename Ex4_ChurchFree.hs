{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE DeriveFunctor #-}

module Ex4_ChurchFree where
  
import Control.Monad.Free (MonadFree, wrap)
import Control.Applicative (Applicative(..))
import Control.Monad (ap, join)


{-
   The free monad generated by composing a functor with itself 0-n times.
   >>= is horrendously inefficient; we must bubble from the top all the way to the 
   leaves of the tree every time!
-}
data Free f a 
  = Wrap (f (Free f a)) 
  | Pure a
  deriving Functor
  
instance Functor f => Applicative (Free f) where
  (<*>) = ap
  pure = Pure
  
instance Functor f => Monad (Free f) where
  (Wrap ffa) >>= f = Wrap $ fmap (>>= f) ffa
  (Pure a) >>= f = f a
  
instance Functor f => MonadFree f (Free f) where 
  wrap = Wrap

foldFree :: Monad m => (forall x . f x -> m x) -> Free f a -> m a
foldFree f (Pure a) = pure a
foldFree f (Wrap ffa) = f ffa >>= foldFree f


{-
   Handle the nested functor: f r -> r
   Handle the pure value: a -> r
-}
newtype CFree f a = CFree 
  { cFold :: forall r. (f r -> r) -> (a -> r) -> r
  }
   
cPure :: a -> CFree f a
cPure = undefined

cWrap :: Functor f => f (CFree f a) -> CFree f a
cWrap = undefined


cFoldFree :: Monad m => (forall x. f x -> m x) -> CFree f a -> m a
cFoldFree = undefined


church :: Functor f => Free f a -> CFree f a
church = undefined

unchurch :: CFree f a -> Free f a
unchurch = undefined

{-
   Bind and map for CFree are completely different from Free's;
   We don't need to know anything about f, because we
   don't touch it.
-}

cMap :: (a -> b) -> CFree f a -> CFree f b
cMap = undefined

cBind :: CFree f a -> (a -> CFree f b) -> CFree f b
cBind = undefined
  

-- Instance definition boilerplate. Note that f need not be a Functor!
instance Functor (CFree f) where
  fmap = cMap

instance Applicative (CFree f) where
  (<*>) = ap  
  pure = cPure

instance Monad (CFree f) where
  (>>=) = cBind

instance Functor f => MonadFree f (CFree f) where 
  wrap = cWrap










  